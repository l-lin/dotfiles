#!/usr/bin/env zsh
#
# git-status-display.zsh
# Displays git status in the style of powerlevel10k's my_git_formatter()
# Extracted from lean.p10k.zsh
# Optimized to minimize git calls for better performance
#

# Branch icon
BRANCH_ICON='ÔÑ¶ '
UNSTAGED_ICON='ÔÅ™ '
UNTRACKED_ICON='ÔÅô '
STAGED_ICON='ÔÅï '
STASHED_ICON='ÔÄú '
WIP_ICON='üöß'

BEHIND_ICON='ÔÑÉ '
AHEAD_ICON='ÔÑÇ '

# Color codes
GREEN=$'\e[0;32m'
YELLOW=$'\e[0;33m'
RED=$'\e[0;31m'
RESET=$'\e[0m'

res=""
branch_part=""
has_changes=false

# Single git call to get multiple values
# Format: is-inside-work-tree|git-dir|short-head|symbolic-ref
read -r IS_REPO GIT_DIR SHORT_HEAD SYMBOLIC_REF <<< $(git rev-parse --is-inside-work-tree --git-dir --short=8 HEAD --symbolic-full-name HEAD 2>/dev/null | tr '\n' ' ')

if [[ $IS_REPO != "true" ]]; then
  echo "Not in a git repository"
  exit 1
fi

# Get comprehensive status in one call
# porcelain v2 format provides branch info, ahead/behind, and file statuses
STATUS_OUTPUT=$(git status --porcelain=v2 --branch 2>/dev/null)

# Parse branch headers
BRANCH=""
REMOTE_BRANCH=""
AHEAD=0
BEHIND=0

while IFS= read -r line; do
  if [[ $line == "# branch.oid"* ]]; then
    continue
  elif [[ $line == "# branch.head"* ]]; then
    BRANCH=${line#\# branch.head }
  elif [[ $line == "# branch.upstream"* ]]; then
    REMOTE_BRANCH=${line#\# branch.upstream }
  elif [[ $line == "# branch.ab"* ]]; then
    # Format: # branch.ab +<ahead> -<behind>
    AHEAD_BEHIND=${line#\# branch.ab }
    AHEAD=${AHEAD_BEHIND%%\ -*}
    AHEAD=${AHEAD#+}
    BEHIND=${AHEAD_BEHIND##*-}
  fi
done <<< "$STATUS_OUTPUT"

# Build branch display
if [[ -n $BRANCH && $BRANCH != "(detached)" ]]; then
  # If branch name is longer than 32 characters, truncate it
  if (( ${#BRANCH} > 32 )); then
    BRANCH="${BRANCH:0:12}‚Ä¶${BRANCH: -12}"
  fi
  branch_part+="${BRANCH_ICON}${BRANCH}"
else
  # Not on a branch - check for tag or show commit
  TAG=$(git describe --tags --exact-match 2>/dev/null)
  if [[ -n $TAG ]]; then
    if (( ${#TAG} > 32 )); then
      TAG="${TAG:0:12}‚Ä¶${TAG: -12}"
    fi
    branch_part+="#${TAG}"
  else
    branch_part+="@${SHORT_HEAD}"
  fi
fi

# Show remote branch if different
if [[ -n $REMOTE_BRANCH && $REMOTE_BRANCH != *"$BRANCH"* ]]; then
  branch_part+=":${REMOTE_BRANCH##*/}"
fi

# Check for "wip" in latest commit (still need separate call, but only one)
COMMIT_MSG=$(git log -1 --pretty=%s 2>/dev/null)
if [[ $COMMIT_MSG == *[Ww][Ii][Pp]* ]]; then
  res+=" ${WIP_ICON}"
  has_changes=true
fi

# Ahead/behind (already parsed from status)
if (( BEHIND > 0 )); then
  res+=" ${RED}${BEHIND_ICON}${BEHIND}${RESET}"
fi
if (( AHEAD > 0 )); then
  [[ $BEHIND -eq 0 ]] && res+=" "
  res+="${GREEN}${AHEAD_ICON}${AHEAD}${RESET}"
fi

# Stashes (need separate call)
STASHES=$(git stash list 2>/dev/null | wc -l | tr -d ' ')
if (( STASHES > 0 )); then
  res+=" ${STASHED_ICON}${STASHES}"
fi

# Git action (merge, rebase, etc.) - using GIT_DIR from earlier
if [[ -f "$GIT_DIR/MERGE_HEAD" ]]; then
  res+=" merge"
  has_changes=true
elif [[ -d "$GIT_DIR/rebase-merge" ]] || [[ -d "$GIT_DIR/rebase-apply" ]]; then
  res+=" rebase"
  has_changes=true
elif [[ -f "$GIT_DIR/CHERRY_PICK_HEAD" ]]; then
  res+=" cherry-pick"
  has_changes=true
elif [[ -f "$GIT_DIR/REVERT_HEAD" ]]; then
  res+=" revert"
  has_changes=true
fi

# Parse file statuses from the status output
STAGED=0
UNSTAGED=0
UNTRACKED_COUNT=0
CONFLICTED_COUNT=0

while IFS= read -r line; do
  if [[ $line == "1 "* ]] || [[ $line == "2 "* ]]; then
    # Ordinary changed entries: "1 XY ..."
    # X = staged status, Y = unstaged status
    XY=${line:2:2}
    X=${XY:0:1}
    Y=${XY:1:1}

    if [[ $X != "." ]]; then
      ((STAGED++))
    fi
    if [[ $Y != "." ]]; then
      ((UNSTAGED++))
    fi
  elif [[ $line == "u "* ]]; then
    # Unmerged entries (conflicts)
    ((CONFLICTED_COUNT++))
  elif [[ $line == "? "* ]]; then
    # Untracked files
    ((UNTRACKED_COUNT++))
  fi
done <<< "$STATUS_OUTPUT"

# Display conflicts
if (( CONFLICTED_COUNT > 0 )); then
  res+=" ~${CONFLICTED_COUNT}"
  has_changes=true
fi

# Staged changes
if (( STAGED > 0 )); then
  res+=" ${GREEN}${STAGED_ICON}${STAGED}${RESET}"
  has_changes=true
fi

# Unstaged changes
if (( UNSTAGED > 0 )); then
  res+=" ${RED}${UNSTAGED_ICON}${UNSTAGED}${RESET}"
  has_changes=true
fi

# Untracked files
if (( UNTRACKED_COUNT > 0 )); then
  res+=" ${RED}${UNTRACKED_ICON}${UNTRACKED_COUNT}${RESET}"
  has_changes=true
fi

# Display git status short format (only if there are changes)
if [[ $has_changes == true ]]; then
  git status -sb
  echo
fi

# Apply color to branch based on whether there are changes
if [[ $has_changes == true ]]; then
  branch_colored="${YELLOW}${branch_part}${RESET}"
else
  branch_colored="${GREEN}${branch_part}${RESET}"
fi

# Combine branch with rest of the status
echo "${branch_colored}${res}"
