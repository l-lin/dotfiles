*kotlin.txt*                                                  Kotlin cheatsheet

Kotlin Quick Reference Guide
===============================================================================

This file provides a concise reference for Kotlin syntax and features.

SOURCES~
    https://github.com/alidehkhodaei/kotlin-cheat-sheet
    https://devhints.io/kotlin
    https://quickref.me/kotlin.html

TABLE OF CONTENTS~
    1.  |kotlin-data-types|               Data Types
    2.  |kotlin-data-conversion|          Data Conversion
    3.  |kotlin-string-interpolation|     String Interpolation
    4.  |kotlin-bitwise-operators|        Bitwise Operators
    5.  |kotlin-control-flow|             Control Flow
        |kotlin-if-else|                    If/Else
        |kotlin-when|                       When
        |kotlin-for|                        For Loops & Ranges
        |kotlin-while|                      While/Do-While
        |kotlin-exception|                  Exception Handling
    6.  |kotlin-nothing|                  Nothing Type
    7.  |kotlin-functions|                Functions
        |kotlin-function-declaration|       Function Declaration
        |kotlin-function-default-named|     Default & Named Arguments
        |kotlin-function-return-type|       Return Types
        |kotlin-function-unit|              Unit-returning Functions
        |kotlin-function-local|             Local Functions
        |kotlin-function-generic|           Generic Functions
        |kotlin-function-lambda|            Lambda Expressions
        |kotlin-function-extension|         Extension Functions & Properties
        |kotlin-function-higher-order|      Higher-Order Functions
        |kotlin-function-operator|          Operator Overloading
        |kotlin-function-varargs|           Varargs
        |kotlin-function-infix|             Infix Notation
        |kotlin-function-scope|             Scope Functions
    8.  |kotlin-classes|                  Classes & Objects
        |kotlin-class|                      Class
        |kotlin-property-method|            Properties & Methods
        |kotlin-getter-setter|              Getters & Setters
        |kotlin-visibility|                 Visibility Modifiers
        |kotlin-lateinit|                   Lateinit
        |kotlin-inheritance|                Inheritance
        |kotlin-interface-abstract|         Interface & Abstract
        |kotlin-data-class|                 Data Class
        |kotlin-nested-inner|               Nested & Inner Class
        |kotlin-typealias|                  Typealias
        |kotlin-enum|                       Enum
        |kotlin-sealed|                     Sealed Class
        |kotlin-generic|                    Generic Class
        |kotlin-companion-object|          Companion Object
        |kotlin-static-factory|             Static Factory Methods
        |kotlin-delegation|                 Delegation
        |kotlin-delegated-properties|       Delegated Properties
    9.  |kotlin-collections|              Collections
        |kotlin-array|                      Array
        |kotlin-list|                       List
        |kotlin-map|                        Map
        |kotlin-set|                        Set
   10.  |kotlin-other|                    Other Topics
        |kotlin-destructuring|              Destructuring Declarations
        |kotlin-reflection|                 Reflection
        |kotlin-annotations|                Annotations
        |kotlin-jvm-inline|                 @JvmInline
        |kotlin-packages-imports|           Packages & Imports
        |kotlin-null-safety|                Null Safety
        |kotlin-equality|                   Equality
        |kotlin-comparable|                 Comparable
        |kotlin-regex|                      Regex

===============================================================================
DATA TYPES                                                   *kotlin-data-types*

Primitive and basic types in Kotlin:
>kotlin
    val booleanVar: Boolean = true
    val byteVar: Byte = 127
    val shortVar: Short = 32767
    val intVar: Int = 2147483647
    val longVar: Long = 9223372036854775807L
    val floatVar: Float = 3.14f
    val doubleVar: Double = 3.14159265358979323846
    val charVar: Char = 'A'
    val stringVar: String = "Hello, world!"
<

===============================================================================
DATA CONVERSION                                         *kotlin-data-conversion*

Convert between types:
>kotlin
    val str: String = "123"
    val num: Int = str.toInt() // String to Int

    val dbl: Double = 123.45
    val int: Int = dbl.toInt() // Double to Int

    val lng: Long = 9876543210
    val flt: Float = lng.toFloat() // Long to Float

    val bol: Boolean = true
    val strBol: String = bol.toString() // Boolean to String

    val char: Char = 'A'
    val intChar: Int = char.code // Char to Int (use .code)
    // Conversion of Char to Number is deprecated. Use Char.code property instead.

    val byte: Byte = 127
    val short: Short = byte.toShort() // Byte to Short
<

===============================================================================
STRING INTERPOLATION                               *kotlin-string-interpolation*

Embed variables in strings:
>kotlin
    val name = "Ali"
    val result = "My name is $name"
<

===============================================================================
BITWISE OPERATORS                                     *kotlin-bitwise-operators*

Bitwise operations:
>kotlin
    val k = 0b1010
    val l = 0b1100
    println(k and l) // Prints "8" (0b1000)
    println(k or l)  // Prints "14" (0b1110)
    println(k xor l) // Prints "6" (0b0110)
<

===============================================================================
CONTROL FLOW                                               *kotlin-control-flow*

Conditional and loop constructs.

-------------------------------------------------------------------------------
IF / ELSE                                                      *kotlin-if-else*
>kotlin
    if (condition) {
        // Code to execute if condition is true
    } else {
        // Code to execute if condition is false
    }
<

-------------------------------------------------------------------------------
WHEN                                                              *kotlin-when*
>kotlin
    when (value) {
        condition1 -> // Code to execute if value matches condition1
        condition2 -> // Code to execute if value matches condition2
        else -> // Code to execute if value does not match any condition
    }

    // As expression
    val seasonFirstMonth = when(season) {
        "summer" -> 6
        "winter" -> 12
        "automn" -> 9
        "spring" -> 3
        else -> error("There is only 4 seasons")
    }

    // Ternary-like
    val max = if (a > b) a else b // Similar to ternary operator
<

-------------------------------------------------------------------------------
FOR LOOPS & RANGES                                                 *kotlin-for*
>kotlin
    for (item in collection) {
        // Code to execute for each item in collection
    }
    for (i in 1..10) {
        if (i == 5) break // Exit loop when i is equal to 5
        if (i % 2 == 0) continue // Skip even numbers and continue to the next iteration
        // Code to execute for each odd number between 1 and 10
    }

    // Ranges
    for(i in 0..3) {
        print(i)
    }
    for(i in 0 until 3) {
        print(i)
    }
    for(i in 2..8 step 2) {
        print(i)
    }
    for (i in 3 downTo 0) {
        print(i)
    }
    for (c in 'a'..'d') {
        print(c)
    }

    // Range in if
    if (x in 1..5) {
        print("x is in range from 1 to 5")
    }
<

-------------------------------------------------------------------------------
WHILE / DO-WHILE                                                 *kotlin-while*
>kotlin
    while (condition) {
        // Code to execute as long as condition is true
    }
    do {
        // Code to execute at least once
    } while (condition)
<

-------------------------------------------------------------------------------
EXCEPTION HANDLING                                           *kotlin-exception*
>kotlin
    try {
        // some code
    } catch (e: SomeException) {
        // handler
    } finally {
        // optional finally block
    }
<

===============================================================================
NOTHING                                                         *kotlin-nothing*

The `Nothing` type marks code locations that can never be reached (e.g.,
functions that always throw):
>kotlin
    fun fail(message: String): Nothing {
        throw IllegalArgumentException(message)
        // This function never returns
    }
<

===============================================================================
FUNCTIONS                                                    *kotlin-functions*

-------------------------------------------------------------------------------
FUNCTION DECLARATION                              *kotlin-function-declaration*

Functions are declared with the `fun` keyword.
>kotlin
    fun sayHello() {
        println("Hello!")
        // Prints Hello!
    }
    fun greet(name: String) {
        println("Hello, $name!")
        // Prints Hello, <name>!
    }
<

-------------------------------------------------------------------------------
DEFAULT AND NAMED ARGUMENTS                     *kotlin-function-default-named*

Functions can have default values and named arguments.
>kotlin
    fun greet(name: String = "World", greeting: String = "Hello") {
        println("$greeting, $name!")
        // Prints greeting and name
    }
    fun main() {
        // calling function with default arguments
        greet() // output: Hello, World!

        // calling function with named arguments
        greet(greeting = "Hi", name = "Ali") // output: Hi, Ali!

        // calling function with some named arguments
        greet(name = "Reza") // output: Hello, Reza!
    }
<

-------------------------------------------------------------------------------
RETURN TYPES                                      *kotlin-function-return-type*

Specify return types after the parameter list.
>kotlin
    fun add(a: Int, b: Int): Int {
        return a + b
        // Returns the sum
    }
    fun multiply(a: Int, b: Int) = a * b
    // Returns the product
<

-------------------------------------------------------------------------------
UNIT-RETURNING FUNCTIONS                                 *kotlin-function-unit*

Functions returning `Unit` (like `void` in other languages).
>kotlin
    fun printHello(): Unit {
        print("Hello")
        // Prints Hello
    }
<

-------------------------------------------------------------------------------
LOCAL FUNCTIONS                                         *kotlin-function-local*

Functions can be declared inside other functions.
>kotlin
    fun main() {
        fun printMessage(message: String) {
            println("Message: $message")
            // Prints the message
        }

        printMessage("Hello, world!")
    }
<

-------------------------------------------------------------------------------
GENERIC FUNCTIONS                                     *kotlin-function-generic*

Functions can be generic.
>kotlin
    fun <T> function(item: T) {
        // ...
    }
<

-------------------------------------------------------------------------------
LAMBDA EXPRESSIONS                                     *kotlin-function-lambda*

Anonymous functions (lambdas) can be assigned to variables.
>kotlin
    val sum = { a: Int, b: Int -> a + b }
    // Lambda that adds two numbers
    val sum = { a: Int, b: Int -> a + b }
    // Lambda that squares a number
    val square: (Int) -> Int = { it * it }
<

-------------------------------------------------------------------------------
EXTENSION FUNCTIONS & PROPERTIES                    *kotlin-function-extension*

Add new functions or properties to existing types.
>kotlin
    fun String.reverse(): String {
        return this.reversed()
    }

    val String.firstChar: Char
        get() = this[0]

    fun main() {
        val str = "Ali"
        println(str.reverse())  // Prints "ilA"
        println(str.firstChar)  // Prints "A"
    }
<

-------------------------------------------------------------------------------
HIGHER-ORDER FUNCTIONS                           *kotlin-function-higher-order*

A higher-order function is a function that takes another function as parameter
and/or returns a function.

Taking Functions as Parameters

>kotlin
    fun calculate(x: Int, y: Int, operation: (Int, Int) -> Int): Int {
        return operation(x, y)
    }
    fun sum(x: Int, y: Int) = x + y
    // Function to sum two numbers
    fun main() {
        val sumResult = calculate(1, 7, ::sum)
        val mulResult = calculate(1, 7) { a, b -> a * b }
    }
<

Returning Functions

>kotlin
    fun operation(): (Int) -> Int {
        return ::square
        // Returns a function
    }
    fun square(x: Int) = x * x
    // Squares a number
    fun main() {
        val func = operation()
        println(func(7))
    }
<

-------------------------------------------------------------------------------
OPERATOR OVERLOADING                                 *kotlin-function-operator*

Operator overloading in Kotlin allows you to define and use custom operators for your own classes and types.
>kotlin
    data class Point(val x: Int, val y: Int) {
        operator fun plus(other: Point): Point {
            return Point(x + other.x, y + other.y)
            // Overloads the + operator
        }
    }
    fun main() {
        val p1 = Point(1, 2)
        val p2 = Point(3, 4)
        val p3 = p1 + p2 // using the overloaded '+' operator
        println(p3) // Output: Point(x=4, y=6)
    }
<

-------------------------------------------------------------------------------
VARARGS (VARIABLE NUMBER OF ARGUMENTS)                *kotlin-function-varargs*

Varargs is a feature that allows you to pass a variable number of arguments of
the same type to a function.

>kotlin
    fun printNumbers(vararg numbers: Int) {
        for (number in numbers) {
            println(number)
            // Prints each number
        }
    }
    fun main() {
        printNumbers(1, 2, 3) // prints 1, 2, 3
        printNumbers(4, 5, 6, 7, 8) // prints 4, 5, 6, 7, 8
    }
<

-------------------------------------------------------------------------------
INFIX NOTATION                                          *kotlin-function-infix*

Infix in Kotlin allows you to define functions that can be called using infix
notation (i.e., without using parentheses and the dot notation).
>kotlin
    infix fun Int.times(str: String) = str.repeat(this)

    fun main() {
        val str = 5 times "Hello "
        println(str) // Output: "Hello Hello Hello Hello Hello "
    }
<

-------------------------------------------------------------------------------
SCOPE FUNCTIONS                                         *kotlin-function-scope*

Kotlin provides several scope functions: let, run, with, apply, also.

`let` can be used for scoping and null-checks. When called on an object, let
executes the given block of code and returns the result of its last
expression. The object is accessible inside the block by the reference it (by
default) or a custom name.

>kotlin
    val message: String? = "Hello"
    message?.let {
        print(it.toUpperCase())
    }
<

Like `let`, `run` is another scoping function from the standard library.
Basically, it does the same: executes a code block and returns its result. The
difference is that inside run the object is accessed by this. This is useful
when you want to call the object's methods rather than pass it as an argument.

>kotlin
    val message: String? = "Hello"
    message?.run {
        print(this.toUpperCase())
    }
<

`with` is a non-extension function that can access members of its argument
concisely: you can omit the instance name when referring to its members.

>kotlin
    val person = Person("Ali", 24)
    val message = with(person) {
        "My name is $name and I'm $age years old."
    }
<

`apply` executes a block of code on an object and returns the object itself.
Inside the block, the object is referenced by this. This function is handy for
initializing objects.

>kotlin
    val person = Person("Ali", 24)
    person.apply {
        name = "Ali"
        age = 24
    }
<

`also` works like apply: it executes a given block and returns the object
called. Inside the block, the object is referenced by it, so it's easier to
pass it as an argument. This function is handy for embedding additional
actions, such as logging in call chains.

>kotlin
    val message: String? = "Hello"
    message?.also {
        print(it.toUpperCase())
    }
<

-------------------------------------------------------------------------------
CLASSES AND OBJECTS                                              *kotlin-class*

A class is a blueprint for creating objects. An object is an instance of a class.
>kotlin
    class Person(val name: String, var age: Int) // class
    val person = Person("Ali", 24) // object
<

-------------------------------------------------------------------------------
PROPERTIES AND METHODS                                 *kotlin-property-method*

Properties are variables that are part of a class/object. Methods are
functions that are part of a class/object.
>kotlin
    class Person(val name: String) {
        var age = 0 // property
        fun sayHello() { // method
            println("Hello, my name is $name")
        }
    }
    val person = Person("Ali")
    person.age = 24
    person.sayHello()
<

-------------------------------------------------------------------------------
GETTERS AND SETTERS                                      *kotlin-getter-setter*

Getters and setters are accessors used to retrieve and modify the value of a variable.
>kotlin
    class Person {
        var name: String = ""
            get() = field.uppercase()
            set(value) {
                field = "Name: $value"
            }
        var age = 24 // has default getter and setter
        val username = "Ali" // has default getter
    }
<

-------------------------------------------------------------------------------
VISIBILITY MODIFIERS                                        *kotlin-visibility*

- private: restricts visibility to the same class.
- protected: restricts visibility to the same class and its subclasses.
- internal: restricts visibility to the same module.
- public: allows visibility from anywhere.

-------------------------------------------------------------------------------
LATEINIT                                                      *kotlin-lateinit*

`lateinit` is used for variables that will be initialized later.
>kotlin
    lateinit var myLateInitVar: String
    // The variable is not initialized yet, so trying to access it will throw an exception
    // println(myLateInitVar) // This line would throw a "lateinit property has not been initialized" exception

    // Sometime later, the variable is initialized
    myLateInitVar = "Hello World"

    // Now we can access the variable without an exception
    println(myLateInitVar) // Prints "Hello World"
<

-------------------------------------------------------------------------------
INHERITANCE                                                *kotlin-inheritance*

Classes and methods are final by default in Kotlin. Use `open` to allow inheritance.
>kotlin
    open class Animal(val name: String) {  // `open` allows this class to be inherited
        open fun makeSound() {             // `open` allows this method to be overridden
            println("Animal sound")
        }

        fun sleep() {                      // Not open - cannot be overridden
            println("Sleeping...")
        }
    }

    class Dog(name: String): Animal(name) {
        override fun makeSound() {         // Must use `override` when overriding
            println("Woof!")
        }

        // sleep() cannot be overridden because it's not marked as `open`
    }
<

-------------------------------------------------------------------------------
INTERFACE AND ABSTRACT                              *kotlin-interface-abstract*

Interfaces define contracts that classes must implement. Abstract classes can have
both abstract and concrete implementations.
>kotlin
    interface Vehicle {
        fun start()                        // Abstract by default - must be implemented
        fun stop()                         // Abstract by default - must be implemented
        val name: String                   // Abstract property - must be implemented

        fun honk() {                       // Default implementation - can be overridden
            println("Beep beep!")
        }
    }

    abstract class Animal {
        abstract fun makeSound()           // Must be implemented by subclasses

        open fun move() {                  // Has implementation - can be overridden
            println("Moving...")
        }

        fun breathe() {                    // Final implementation - cannot be overridden
            println("Breathing...")
        }
    }

    class Car(override val name: String) : Vehicle {
        override fun start() = println("Engine started")
        override fun stop() = println("Engine stopped")
        // honk() inherited with default implementation
    }
<

-------------------------------------------------------------------------------
DATA CLASS                                                  *kotlin-data-class*

Data classes automatically generate useful methods like equals(), hashCode(),
toString(), copy(), and destructuring declarations.
>kotlin
    data class Person(val name: String, var age: Int)

    val person1 = Person("Ali", 24)
    val person2 = Person("Ali", 24)
    val person3 = Person("Sara", 30)

    // toString() - automatically generated
    println(person1) // Person(name=Ali, age=24)

    // equals() and hashCode() - automatically generated
    println(person1 == person2) // true (same content)
    println(person1 == person3) // false (different content)

    // copy() - create a copy with some properties changed
    val olderPerson = person1.copy(age = 25)
    println(olderPerson) // Person(name=Ali, age=25)

    // Destructuring declarations
    val (name, age) = person1
    println("Name: $name, Age: $age") // Name: Ali, Age: 24

    // componentN() functions - automatically generated
    println(person1.component1()) // Ali (first property)
    println(person1.component2()) // 24 (second property)
<

Requirements for data classes:
- Primary constructor must have at least one parameter
- All primary constructor parameters must be marked as val or var
  - Cannot be abstract, open, sealed, or inner
- May only implement interfaces (before Kotlin 1.1)

-------------------------------------------------------------------------------
NESTED AND INNER CLASS                                    *kotlin-nested-inner*

Nested classes don't have access to outer class members. Inner classes do have
access to outer class members through an implicit reference.
>kotlin
    class Outer {
        private val outerProperty = "Outer property"

        // Nested class - no access to outer class members
        class Nested {
            fun foo() {
                // Cannot access outerProperty - compilation error
                println("I'm nested but independent")
            }
        }

        // Inner class - has access to outer class members
        inner class Inner {
            fun bar() {
                println(outerProperty) // Can access outer class members
                println("I can access: $outerProperty")
            }

            fun getOuterReference(): Outer {
                return this@Outer // Reference to outer class instance
            }
        }

        fun createInstances() {
            val nested = Nested()        // No outer instance needed
            val inner = Inner()          // Uses this outer instance

            nested.foo()
            inner.bar()
        }
    }

    fun main() {
        // Creating nested class instance - no outer instance required
        val nested = Outer.Nested()
        nested.foo()

        // Creating inner class instance - requires outer instance
        val outer = Outer()
        val inner = outer.Inner()
        inner.bar()

        // Alternative syntax for inner class
        val inner2 = Outer().Inner()
    }
<

-------------------------------------------------------------------------------
TYPEALIAS                                                    *kotlin-typealias*

Type aliases create alternative names for existing types, making code more readable
and maintainable. They don't create new types - just alternative names.
>kotlin
    // Function type aliases
    typealias NumberPredicate = (Int) -> Boolean
    typealias NumberMapper = (Int) -> String
    typealias EventHandler = (String) -> Unit

    val numbers = listOf(1, 2, 3, 4, 5)
    val even: NumberPredicate = { number -> number % 2 == 0 }
    val mapper: NumberMapper = { number -> "Number is $number" }

    fun processNumbers(predicate: NumberPredicate, mapper: NumberMapper) {
        numbers.filter(predicate).map(mapper).forEach(::println)
    }

    // Class type aliases
    typealias UserMap = Map<String, User>
    typealias UserList = List<User>
    typealias StringPair = Pair<String, String>

    data class User(val name: String, val email: String)

    fun getUsers(): UserList = listOf(
        User("Alice", "alice@example.com"),
        User("Bob", "bob@example.com")
    )

    fun getUserMap(): UserMap = mapOf(
        "alice" to User("Alice", "alice@example.com"),
        "bob" to User("Bob", "bob@example.com")
    )

    // Generic type aliases
    typealias StringCallback<T> = (T) -> String
    typealias Repository<T> = Map<String, T>

    val stringifyInt: StringCallback<Int> = { "Number: $it" }
    val userRepo: Repository<User> = mapOf("1" to User("Alice", "alice@example.com"))

    // Nested class aliases
    class Outer {
        inner class Inner
    }
    typealias OuterInner = Outer.Inner
<

Benefits of type aliases:
- Make complex generic types more readable
- Provide meaningful names for function types
- Help avoid repetition of long type declarations
- Improve code documentation and maintainability

-------------------------------------------------------------------------------
ENUM                                                              *kotlin-enum*

>kotlin
    enum class Color {
        RED, GREEN, BLUE
    }
<

-------------------------------------------------------------------------------
SEALED CLASS                                                    *kotlin-sealed*

Sealed classes restrict inheritance to a known set of subclasses. All subclasses
must be declared in the same file. Perfect for representing restricted class hierarchies.
>kotlin
    sealed class Result<out T>
    data class Success<T>(val data: T) : Result<T>()
    data class Error(val message: String) : Result<Nothing>()
    object Loading : Result<Nothing>()

    // Usage with when expression - compiler ensures exhaustiveness
    fun handleResult(result: Result<String>) = when (result) {
        is Success -> println("Data: ${result.data}")
        is Error -> println("Error: ${result.message}")
        is Loading -> println("Loading...")
        // No else needed - compiler knows all cases are covered
    }

    // More complex example
    sealed class Shape {
        abstract fun area(): Double
    }

    data class Circle(val radius: Double) : Shape() {
        override fun area(): Double = Math.PI * radius * radius
    }

    data class Rectangle(val width: Double, val height: Double) : Shape() {
        override fun area(): Double = width * height
    }

    object EmptyShape : Shape() {
        override fun area(): Double = 0.0
    }

    fun calculateArea(shape: Shape): Double = when (shape) {
        is Circle -> shape.area()
        is Rectangle -> shape.area()
        is EmptyShape -> 0.0
        // Compiler ensures all sealed subclasses are handled
    }

    // Sealed interfaces (Kotlin 1.5+)
    sealed interface UIEvent
    data class Click(val x: Int, val y: Int) : UIEvent
    data class Scroll(val delta: Int) : UIEvent
    object Refresh : UIEvent

    fun handleUIEvent(event: UIEvent) = when (event) {
        is Click -> println("Clicked at ${event.x}, ${event.y}")
        is Scroll -> println("Scrolled by ${event.delta}")
        is Refresh -> println("Refreshing...")
    }
<

Key benefits of sealed classes:
- Exhaustive when expressions - no need for else branch
- Restricted inheritance - only known subclasses allowed
- Type safety - compiler knows all possible subtypes
- Perfect for state machines and result types
- Can be used with data classes and objects

-------------------------------------------------------------------------------
GENERIC CLASS                                                  *kotlin-generic*

Generic classes allow you to write classes that work with different types while
maintaining type safety. Kotlin supports variance annotations (in, out) for safe
type conversions.
>kotlin
    // Basic generic class
    class Box<T>(initialValue: T) {
        var value: T = initialValue

        fun get(): T = value
        fun set(newValue: T) {
            value = newValue
        }
    }

    // Multiple type parameters
    class Pair<T, U>(val first: T, val second: U) {
        fun swap(): Pair<U, T> = Pair(second, first)
    }

    // Generic class with constraints
    class NumberContainer<T : Number>(val number: T) {
        fun getDoubleValue(): Double = number.toDouble()
        fun isPositive(): Boolean = number.toDouble() > 0
    }

    // Variance annotations
    // Covariant (out) - can read T but not write
    interface Producer<out T> {
        fun produce(): T
        // fun consume(item: T) // Not allowed - can't consume covariant type
    }

    // Contravariant (in) - can write T but not read
    interface Consumer<in T> {
        fun consume(item: T)
        // fun produce(): T // Not allowed - can't produce contravariant type
    }

    // Invariant - can both read and write (default)
    interface Storage<T> {
        fun store(item: T)
        fun retrieve(): T
    }

    // Usage examples
    fun main() {
        val stringBox = Box("Hello")
        val intBox = Box(42)

        println(stringBox.get()) // Hello
        intBox.set(100)
        println(intBox.get())    // 100

        val coordinates = Pair(10.5, 20.3)
        val swapped = coordinates.swap() // Pair<Double, Double>

        val intContainer = NumberContainer(42)
        val doubleContainer = NumberContainer(3.14)
        println(intContainer.isPositive()) // true

        // Variance in action
        val stringProducer: Producer<String> = object : Producer<String> {
            override fun produce(): String = "Hello"
        }
        // This works due to covariance
        val anyProducer: Producer<Any> = stringProducer
    }

    // Generic constraints with multiple bounds
    interface Drawable {
        fun draw()
    }

    interface Movable {
        fun move(x: Int, y: Int)
    }

    class GameEntity<T> where T : Drawable, T : Movable {
        fun processEntity(entity: T) {
            entity.draw()
            entity.move(10, 20)
        }
    }
<

Key concepts:
- Type parameters use angle brackets <T, U, V>
- Constraints limit type parameters (T : Number, T : Comparable<T>)
- out T (covariant) - can only produce T, enables safe upcasting
- in T (contravariant) - can only consume T, enables safe downcasting
- Multiple bounds use where clause
- Star projection (*) represents unknown type
<

-------------------------------------------------------------------------------
COMPANION OBJECT                                      *kotlin-companion-object*

A companion object is a singleton object whose members can be accessed directly
through the containing class name, similar to static members in other languages.
Each class can have only one companion object.

>kotlin
    class MyClass {
        companion object {
            const val CONSTANT = "Hello"
            var counter = 0

            fun create(): MyClass {
                counter++
                return MyClass()
            }

            fun getInfo(): String = "Created $counter instances"
        }
    }

    fun main() {
        println(MyClass.CONSTANT)  // Hello
        val obj1 = MyClass.create()
        val obj2 = MyClass.create()
        println(MyClass.getInfo()) // Created 2 instances
    }
<

Named companion objects:
>kotlin
    class MyClass {
        companion object Factory {
            fun create(): MyClass = MyClass()
        }
    }

    fun main() {
        val obj = MyClass.create()        // Access through class
        val obj2 = MyClass.Factory.create() // Access through companion name
    }
<

Companion objects can implement interfaces:
>kotlin
    interface Factory<T> {
        fun create(): T
    }

    class Person(val name: String) {
        companion object : Factory<Person> {
            override fun create(): Person = Person("Default")
        }
    }
<

-------------------------------------------------------------------------------
STATIC FACTORY METHODS                                 *kotlin-static-factory*

Static factory methods are functions that return instances of a class instead
of using constructors directly. In Kotlin, these are implemented as companion
object functions or top-level functions.

>kotlin
    class Person private constructor(val name: String, val age: Int) {
        companion object {
            // Named factory methods with descriptive names
            fun createAdult(name: String, age: Int): Person? {
                return if (age >= 18) Person(name, age) else null
            }

            fun createChild(name: String, age: Int): Person? {
                return if (age < 18) Person(name, age) else null
            }

            // Factory method for creating from string
            fun fromString(data: String): Person? {
                val parts = data.split(",")
                return if (parts.size == 2) {
                    val name = parts[0].trim()
                    val age = parts[1].trim().toIntOrNull()
                    if (age != null) Person(name, age) else null
                } else null
            }

            // Cached instances
            private val unknownPerson = Person("Unknown", 0)
            fun unknown(): Person = unknownPerson
        }
    }

    fun main() {
        val adult = Person.createAdult("Alice", 25)
        val child = Person.createChild("Bob", 12)
        val parsed = Person.fromString("Charlie,30")
        val unknown = Person.unknown()
    }
<

Benefits of static factory methods:
- Descriptive names (unlike constructors)
- Can return null or different subtypes
- Can cache and reuse instances
- Don't have to create a new object each time
- Can have multiple factory methods with the same parameter types

-------------------------------------------------------------------------------
DELEGATION                                                  *kotlin-delegation*

Class delegation allows a class to implement an interface by delegating to another
object. The `by` keyword automatically implements interface methods by forwarding
calls to the delegate object.
>kotlin
    interface Base {
        fun print()
        fun greet(name: String)
    }

    class BaseImpl(val x: Int) : Base {
        override fun print() { println("BaseImpl: $x") }
        override fun greet(name: String) { println("Hello, $name from BaseImpl") }
    }

    // Derived delegates all Base methods to the provided instance
    class Derived(b: Base) : Base by b {
        // Can override specific methods if needed
        override fun greet(name: String) {
            println("Custom greeting from Derived")
        }
    }

    // Multiple delegation
    interface Printer {
        fun print()
    }

    interface Logger {
        fun log(message: String)
    }

    class ConsolePrinter : Printer {
        override fun print() { println("Printing to console") }
    }

    class FileLogger : Logger {
        override fun log(message: String) { println("Logging: $message to file") }
    }

    class MultiService(
        printer: Printer,
        logger: Logger
    ) : Printer by printer, Logger by logger {
        fun doWork() {
            print()
            log("Work completed")
        }
    }

    fun main() {
        val base = BaseImpl(42)
        val derived = Derived(base)
        derived.print()         // BaseImpl: 42 (delegated)
        derived.greet("Alice")  // Custom greeting from Derived (overridden)

        val service = MultiService(ConsolePrinter(), FileLogger())
        service.doWork()
    }
<


-------------------------------------------------------------------------------
DELEGATED PROPERTIES                              *kotlin-delegated-properties*

Delegated properties allow property access to be handled by another object (delegate).
Kotlin provides built-in delegates like lazy, observable, and others.
>kotlin
    import kotlin.properties.Delegates

    class User {
        // Lazy initialization - computed on first access
        val expensiveProperty: String by lazy {
            println("Computing expensive value...")
            "Expensive result"
        }

        // Observable property - notifies on changes
        var name: String by Delegates.observable("Initial") { property, oldValue, newValue ->
            println("${property.name} changed from $oldValue to $newValue")
        }

        // Vetoable property - can reject changes
        var age: Int by Delegates.vetoable(0) { property, oldValue, newValue ->
            println("Trying to change ${property.name} from $oldValue to $newValue")
            newValue >= 0 // Only allow non-negative ages
        }

        // NotNull delegate - for late initialization
        var lateInitProperty: String by Delegates.notNull()
    }

    // Custom delegate
    class LoggingDelegate<T>(private var value: T) {
        operator fun getValue(thisRef: Any?, property: KProperty<*>): T {
            println("Getting ${property.name} = $value")
            return value
        }

        operator fun setValue(thisRef: Any?, property: KProperty<*>, value: T) {
            println("Setting ${property.name} = $value")
            this.value = value
        }
    }

    class Example {
        var customProperty: String by LoggingDelegate("initial")

        // Map delegation - properties backed by a map
        private val map = mutableMapOf<String, Any?>()
        var mapProperty: String by map
        var anotherMapProperty: Int by map
    }

    fun main() {
        val user = User()

        // Lazy evaluation
        println(user.expensiveProperty) // Computes and prints result
        println(user.expensiveProperty) // Returns cached result

        // Observable property
        user.name = "Alice"  // Prints change notification
        user.name = "Bob"    // Prints change notification

        // Vetoable property
        user.age = 25        // Allowed
        user.age = -5        // Rejected, age remains 25

        // Custom delegate
        val example = Example()
        example.customProperty = "new value"  // Prints logging
        println(example.customProperty)       // Prints logging

        // Map delegation
        example.mapProperty = "hello"
        example.anotherMapProperty = 42
    }
<

Common delegated property patterns:
- lazy: Thread-safe lazy initialization
- observable: Notifies when property changes
- vetoable: Can prevent property changes
- notNull: Late initialization for non-null properties
- Map delegation: Properties backed by a map
- Custom delegates: Implement getValue/setValue operators
<

===============================================================================
COLLECTIONS                                                 *kotlin-collections*


-------------------------------------------------------------------------------
ARRAY                                                            *kotlin-array*

>kotlin
    val numbers = arrayOf(1, 2, 3, 4, 5)
    numbers[0] = 10
    // Declare an array of integers
    val numbers = arrayOf(1, 2, 3, 4, 5)
    // Declare an array of strings
    val names = arrayOf("Alice", "Bob", "Charlie", "Dave")
    // Declare an array of a specific size
    val array = arrayOfNulls<Int>(10)
    // Declare an array of integers with a specified size and initial value
    val array2 = Array<Int>(7) { i -> i*i }
    val filledArray = IntArray(5) { index -> index * 2 } // Other type: BooleanArray, ShortArray, DoubleArray and etc.
    // Access an element at a specific index
    val firstNumber = numbers[0]
    // Access the last element of an array
    val lastNumber = numbers[numbers.size - 1]
    // Modify an element at a specific index
    numbers[0] = 10
    // Sort the array
    numbers.sort()
    // Reverse the array
    names.reverse()
<

-------------------------------------------------------------------------------
LIST                                                              *kotlin-list*
  >kotlin
      val list = listOf(1, 2, 3, 4, 5) // Immutable list
      // list.add(4) // Error: Unresolved reference. Immutable lists cannot be modified
      // list.remove(3) // Error: Unresolved reference. Immutable lists cannot be modified
      val second = list[1] // Returns the element at index 1 (2)

      val list2 = mutableListOf(1, 2, 3, 4, 5) // Mutable list
      list2.add(6) // Adds 6 to the end
      list2.remove(3) // Removes the first occurrence of 3
      val value = list2[1] // Returns the element at index 1

      val numbers = mutableListOf(1, 2, 3)
      numbers.add(4) // Adds the specified element to the end of the list
      numbers.remove(3) // Removes the first occurrence of the specified element from the list
      val element = numbers[1] // Returns the element at the specified index in the list
  <

-------------------------------------------------------------------------------
MAP                                                                *kotlin-map*
>kotlin
    val map = mapOf(1 to "one", 2 to "two", 3 to "three")
	val numbers = mutableMapOf("one" to 1, "two" to 2, "three" to 3)
	numbers.put("four", 4) // Associates the specified value with the specified key in the map
	numbers.remove("two") // Removes the mapping for the specified key from the map if it is present
	numbers.containsKey("two") // Returns true if the map contains the specified key
<

-------------------------------------------------------------------------------
SET                                                                *kotlin-set*
>kotlin
    val set = setOf(1, 2, 3, 4, 5)
	val set2 = mutableSetOf(1, 2, 3, 4, 5)
	val numbers = mutableSetOf(1, 2, 3)
	numbers.add(4) // Adds the specified element to the set if it is not already present
	numbers.remove(3) // Removes the specified element from the set if it is present
	numbers.contains(1) //  Returns true if the set contains the specified element
<

===============================================================================
OTHER TOPICS                                                     *kotlin-other*

-------------------------------------------------------------------------------
DESTRUCTURING DECLARATIONS                               *kotlin-destructuring*

Destructuring declarations allow you to unpack an object into multiple variables
in a single statement. Works with data classes, collections, and custom classes
that provide componentN() functions.
>kotlin
    // Data class destructuring - automatic componentN() functions
    data class Person(val name: String, val age: Int, val email: String)

    val person = Person("Alice", 25, "alice@example.com")
    val (name, age, email) = person
    println("Name: $name, Age: $age, Email: $email")

    // Partial destructuring - skip unwanted components with underscore
    val (firstName, _, userEmail) = person  // Skip age
    println("$firstName: $userEmail")

    // Collection destructuring
    val coordinates = listOf(10, 20, 30)
    val (x, y, z) = coordinates
    println("Position: ($x, $y, $z)")

    // Pair and Triple destructuring
    val pair = "key" to 42
    val (key, value) = pair
    println("$key = $value")

    val triple = Triple("first", "second", "third")
    val (first, second, third) = triple

    // Map entries destructuring
    val map = mapOf("apple" to 5, "banana" to 3, "orange" to 8)
    for ((fruit, quantity) in map) {
        println("$fruit: $quantity")
    }

    // In lambdas
    val pairs = listOf("a" to 1, "b" to 2, "c" to 3)
    pairs.forEach { (letter, number) ->
        println("$letter = $number")
    }

    // Custom class with componentN() functions
    class Point(val x: Int, val y: Int) {
        operator fun component1() = x
        operator fun component2() = y
        // Can add more componentN() functions as needed
    }

    val point = Point(100, 200)
    val (px, py) = point
    println("Point coordinates: ($px, $py)")

    // Destructuring in function returns
    fun getNameAndAge(): Pair<String, Int> = "Bob" to 30

    val (userName, userAge) = getNameAndAge()
    println("User: $userName, Age: $userAge")

    // Nested destructuring
    data class Address(val street: String, val city: String)
    data class User(val name: String, val address: Address)

    val user = User("Charlie", Address("123 Main St", "Springfield"))
    val (name2, address) = user
    val (street, city) = address
    println("$name2 lives at $street, $city")
<

How destructuring works:
- Data classes automatically generate component1(), component2(), etc.
- Collections provide componentN() for indexed access
- Pairs and Triples have built-in component functions
- Custom classes can implement operator fun componentN()
- Use underscore (_) to skip unwanted components
- Works in for loops, lambdas, and function returns

-------------------------------------------------------------------------------
REFLECTION                                                  *kotlin-reflection*

>kotlin
    val stringClass = String::class.java
    // Obtain a Class object for the String class
    val stringClass = String::class.java
    // Get the fields of the String class and print their names
    val fields = stringClass.declaredFields
    for (field in fields) {
        println(field.name)
    }
    // Get the methods of the String class and print their names
    val methods = stringClass.declaredMethods
    for (method in methods) {
        println(method.name)
    }
<

-------------------------------------------------------------------------------
ANNOTATIONS                                                *kotlin-annotations*

>kotlin
    @Deprecated("Use newMethod() instead", ReplaceWith("newMethod()"))
    fun oldMethod() {
        // ...
    }
<

-------------------------------------------------------------------------------
@JVMINLINE                                                 *kotlin-jvm-inline*

The `@JvmInline` annotation is used with value classes to create compile-time
wrappers that are inlined for better performance while maintaining type safety.
The wrapper is eliminated in JVM bytecode when possible.

>kotlin
    @JvmInline
    value class UserId(val id: String) {
        fun isValid(): Boolean = id.isNotEmpty()
    }

    @JvmInline
    value class Password(private val value: String) {
        override fun toString(): String = "***"
    }

    fun main() {
        val userId = UserId("user123")
        val password = Password("secret")
        println(userId.isValid()) // true
        println(password) // ***
    }
<

-------------------------------------------------------------------------------
PACKAGES AND IMPORTS                                  *kotlin-packages-imports*

>kotlin
    package com.example.models

    class Person(val name: String, val age: Int)
<

>kotlin
    import com.example.models.Person

    fun main() {
        val person = Person("Ali", 24)
        println("Name: ${person.name}, Age: ${person.age}")
    }
<

-------------------------------------------------------------------------------
NULL SAFETY                                                *kotlin-null-safety*

Kotlin's null safety prevents null pointer exceptions at compile time by
distinguishing between nullable and non-nullable types. The type system
ensures null safety through various operators and checks.
>kotlin
    // Nullable vs Non-nullable types
    var nullableStr: String? = null        // Can be null
    var nonNullStr: String = "Hello"       // Cannot be null
    val nullableInt: Int? = null
    val nonNullInt: Int = 42

    // Safe call operator (?.) - returns null if receiver is null
    println(nullableStr?.length)           // null (safe, no exception)
    println(nullableStr?.uppercase())      // null (safe, no exception)

    // Chaining safe calls
    data class Person(val name: String?)
    data class Company(val ceo: Person?)

    val company: Company? = Company(Person("Alice"))
    val ceoNameLength = company?.ceo?.name?.length  // Safe chain
    println(ceoNameLength) // 5

    val emptyCompany: Company? = null
    println(emptyCompany?.ceo?.name?.length) // null (no crash)

    // Elvis operator (?:) - provides default value for null
    val len = nullableStr?.length ?: -1
    println(len) // -1

    val name = nullableStr ?: "Default Name"
    println(name) // Default Name

    // Elvis with early return
    fun processString(str: String?): String {
        val nonNullStr = str ?: return "Empty string provided"
        return "Processed: $nonNullStr"
    }

    println(processString(null))      // Empty string provided
    println(processString("Hello"))   // Processed: Hello

    // Not-null assertion operator (!!) - converts nullable to non-null
    // Use with caution - throws KotlinNullPointerException if null
    val nullableValue: String? = "Not null"
    val definitelyNotNull = nullableValue!! // Risky - only if you're sure
    println(definitelyNotNull.length)

    // Safe casting with 'as?'
    val obj: Any = "Hello"
    val str: String? = obj as? String       // Safe cast
    val int: Int? = obj as? Int            // null (safe, no exception)
    println(str)  // Hello
    println(int)  // null

    // Let function for null checks
    nullableStr?.let { nonNullValue ->
        println("String length: ${nonNullValue.length}")
        println("Uppercase: ${nonNullValue.uppercase()}")
        // This block only executes if nullableStr is not null
    }

    // Collections and null safety
    val nullableList: List<String>? = null
    val listWithNulls: List<String?> = listOf("Hello", null, "World")
    val nonNullList: List<String> = listOfNotNull("Hello", null, "World")

    println(nullableList?.size)            // null
    println(listWithNulls.size)            // 3
    println(nonNullList)                   // [Hello, World]

    // FilterNotNull for collections
    val filtered = listWithNulls.filterNotNull()
    println(filtered)  // [Hello, World]

    // Platform types (from Java) - use carefully
    // String! means nullable or non-null (compiler can't determine)

    fun exampleChecks() {
        val nullable: String? = null

        // Traditional null check
        if (nullable != null) {
            println(nullable.length) // Smart cast to String
        }

        // Multiple null checks
        if (nullable != null && nullable.isNotEmpty()) {
            println("Non-empty string: $nullable")
        }

        // When expression with null
        when (nullable) {
            null -> println("It's null")
            else -> println("Length: ${nullable.length}")
        }
    }
<

Null safety operators summary:
- ?: Type - nullable type annotation
- ?. - safe call operator (returns null if receiver is null)
- ?: - elvis operator (provides default value for null)
- !! - not-null assertion (throws exception if null)
- as? - safe cast operator (returns null if cast fails)
- let { } - executes block only if receiver is not null

-------------------------------------------------------------------------------
EQUALITY                                                      *kotlin-equality*


In Kotlin there are two types of equality:

- Structural equality (`==` - a check for equals())
- Referential equality (`===` - two references point to the same object)

>kotlin
    data class Person(val name:String,val age:Int)

    val person1=Person("Ali",24)
    val person2=Person("Reza",27)
    var person3=Person("Ali",24)

    print(person1 == person2) // false
    print(person1 != person2) // true
    print(person1 === person2) // false
    print(person1 == person3) // true
    print(person1 === person3) // false
    print(person1 !== person3) // true
<

- The `==` operator in Kotlin is equivalent to calling the `equals()` method.
- Data classes generate an `equals()` method based on their properties, but
  regular classes do not.
- To compare objects for equality based on their contents, you need to
  override the `equals()` method for regular classes.

-------------------------------------------------------------------------------
COMPARABLE                                                  *kotlin-comparable*
>kotlin
    data class Person(val name: String, val age: Int) : Comparable<Person> {
        override fun compareTo(other: Person): Int {
            return this.age.compareTo(other.age)
        }
    }

    val person1 = Person("Ali", 24)
    val person2 = Person("Reza", 30)

	// you can directly use the `<` and `>` operators
    if (person1 < person2) {
        println("${person1.name} is younger than ${person2.name}")
    } else {
        println("${person1.name} is older than ${person2.name}")
    }

    val people = listOf(
        Person("Ali", 24),
        Person("Reza", 40),
        Person("Shabnam", 23)
    )

	// When you use the sorted() or sort() function to sort a list of objects,
	// Kotlin uses the compareTo() method of the objects to determine their
	// natural order. If the objects in the list do not implement the
	// Comparable interface, you will get a compile-time error.
    val sortedPeople = people.sorted()
    println(sortedPeople) // [Person(name=Shabnam, age=23), Person(name=Ali, age=24), Person(name=Reza, age=40)]
<

-------------------------------------------------------------------------------
REGEX                                                            *kotlin-regex*

Regex, short for regular expression, is a sequence of characters that forms a
pattern used to match and manipulate text.

Regex Basics:

- `.`     Matches any character except newline.
- `^`     Matches the start of a string, or start of line in multi-line pattern.
- `\A`    Matches the start of a string.
- `$`     Matches the end of a string, or end of line in multi-line pattern.
- `\Z`    Matches the end of a string.
- `\b`    Matches a word boundary.
- `\B`    Matches a position that is not a word boundary.
- `\d`    Matches a digit (0-9).
- `\D`    Matches a non-digit.
- `\w`    Matches a word character (letter, digit, or underscore).
- `\W`    Matches a non-word character.
- `\s`    Matches a whitespace character (space, tab, newline, etc.).
- `\S`    Matches a non-whitespace character.
- `()`    Groups
- `[]`    Matches any character inside the square brackets.
- `[^]`   Matches any character not inside the square brackets.
- `*`     Matches 0 or more of the preceding element.
- `+`     Matches 1 or more of the preceding element.
- `?`     Matches 0 or 1 of the preceding element.
- `{n}`   Matches exactly n occurrences of the preceding element.
- `{n,}`  Matches n or more occurrences of the preceding element.
- `{n,m}` Matches between n and m occurrences of the preceding element.

Kotlin provides several functions for working with regular expressions, including: matches, find, findAll, replace, split and etc.

>kotlin
    val phoneNumber = "9112233445"
    val regex = Regex("^\\d{10}$")
    println(regex.matches(phoneNumber)) // true
<

vim:ft=help:tw=78:ts=4:noet:norl:
